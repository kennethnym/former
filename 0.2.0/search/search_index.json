{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to former former is a form library for Flutter, inspired by formik . Motivation Formik is one of my favorite React libraries. It is a form library that drastically reduces boilerplate for keeping track of field values, validation, and form submission. Form building in Flutter suffers from similar issues: Developers have to manually keep track of field values, for example using TextEditingController s. Validation and error handling requires imperative logic. This is where former comes in. Features Enabling/disabling form globally Declarative form validation Automatic value tracking via Former form controls. Easy error handling with FormerError widget. Type-safe access of form. API reference API reference on pub.dev","title":"Welcome to former!"},{"location":"#welcome-to-former","text":"former is a form library for Flutter, inspired by formik .","title":"Welcome to former"},{"location":"#motivation","text":"Formik is one of my favorite React libraries. It is a form library that drastically reduces boilerplate for keeping track of field values, validation, and form submission. Form building in Flutter suffers from similar issues: Developers have to manually keep track of field values, for example using TextEditingController s. Validation and error handling requires imperative logic. This is where former comes in.","title":"Motivation"},{"location":"#features","text":"Enabling/disabling form globally Declarative form validation Automatic value tracking via Former form controls. Easy error handling with FormerError widget. Type-safe access of form.","title":"Features"},{"location":"#api-reference","text":"API reference on pub.dev","title":"API reference"},{"location":"error-handling/","text":"Error handling former offers APIs that make it easy to handle form validation errors. The FormerError widget FormerError is a Text widget that displays any validation error of a given field. Like other form controls, it accepts all the arguments of a Text widget. An example Let's consider the following schema: FormSchema ( field: NumberMust ().. beAtLeast ( 10 , 'too small!' ) ) You can use the FormerError widget to display any validation error of the given field: FormerError ( field: Form . field ) If the field doesn't have any error, it will build an empty Container . If there is an error, it will build a Text widget with the error message (in this case 'too small'! ) as the text. The text will have an error color, taken from the Theme in context. Get error messages of a field If you want to get the error message of a field, so that, for example, you can build your own error message widget, you can use the errorOf method of FormerProvider : final provider = Former . of < MyForm > ( context ); final error = provider . errorOf ( MyForm . myField ); If the field doesn't have any error, an empty string is returned. FormInvalidException If you attempt to submit an invalid form, a FormInvalidException will be thrown. To catch it, wrap your Former.of(context).submit call with a try-catch block: try { Former . of ( context ). submit (); } on FormInvalidException catch ( ex ) { print ( 'name of invalid form: ${ ex . invalidForm } ' ); }","title":"Error handling"},{"location":"error-handling/#error-handling","text":"former offers APIs that make it easy to handle form validation errors.","title":"Error handling"},{"location":"error-handling/#the-formererror-widget","text":"FormerError is a Text widget that displays any validation error of a given field. Like other form controls, it accepts all the arguments of a Text widget.","title":"The FormerError widget"},{"location":"error-handling/#an-example","text":"Let's consider the following schema: FormSchema ( field: NumberMust ().. beAtLeast ( 10 , 'too small!' ) ) You can use the FormerError widget to display any validation error of the given field: FormerError ( field: Form . field ) If the field doesn't have any error, it will build an empty Container . If there is an error, it will build a Text widget with the error message (in this case 'too small'! ) as the text. The text will have an error color, taken from the Theme in context.","title":"An example"},{"location":"error-handling/#get-error-messages-of-a-field","text":"If you want to get the error message of a field, so that, for example, you can build your own error message widget, you can use the errorOf method of FormerProvider : final provider = Former . of < MyForm > ( context ); final error = provider . errorOf ( MyForm . myField ); If the field doesn't have any error, an empty string is returned.","title":"Get error messages of a field"},{"location":"error-handling/#forminvalidexception","text":"If you attempt to submit an invalid form, a FormInvalidException will be thrown. To catch it, wrap your Former.of(context).submit call with a try-catch block: try { Former . of ( context ). submit (); } on FormInvalidException catch ( ex ) { print ( 'name of invalid form: ${ ex . invalidForm } ' ); }","title":"FormInvalidException"},{"location":"form-submission/","text":"Form submission former submits form by calling the submit method of your form. The submit method of FormerProvider triggers form submission: final provider = Former . of < MyForm > ( context ); provider . submit (); As mentioned in the error handling section, FormerProvider.submit throws a FormInvalidException if the form is invalid. During the submission, your form is automatically disabled. Afterwards, your form is re-enabled. Returning results Your submit method can return a value after submission. To do so, your form's implementation of the submit method should return Future<SomeValue> , where SomeValue is the type of the value that will be returned. Let's assume a String is returned. The submit method should look like this: @Formable () abstract class _MyForm extends FormerForm { Future < String > submit ( BuildContext context ) async { // submission logic return '' ; } } Then, you should pass the type of the return value to FormerProvider.submit : final provider = Former . of < MyForm > ( context ); final result = provider . submit < String > (); Unfortunately, due to the limitation of Dart's type system, it is currently impossible to infer the return type of your implementation of the submit method. Delegating submission to Bloc It is also possible to delegate form submission to a bloc: @Formable () abstract class _MyForm extends FormerForm { Future < void > submit ( BuildContext context ) async { BlocProvider . of < MyBloc > ( context ). add ( FormSubmitted ( this )); } } Your bloc can get the form in two ways: From the event object added (as shown above), Obtain the form with Former.of(context).form . Pick an approach depending on your use case.","title":"Form submission"},{"location":"form-submission/#form-submission","text":"former submits form by calling the submit method of your form. The submit method of FormerProvider triggers form submission: final provider = Former . of < MyForm > ( context ); provider . submit (); As mentioned in the error handling section, FormerProvider.submit throws a FormInvalidException if the form is invalid. During the submission, your form is automatically disabled. Afterwards, your form is re-enabled.","title":"Form submission"},{"location":"form-submission/#returning-results","text":"Your submit method can return a value after submission. To do so, your form's implementation of the submit method should return Future<SomeValue> , where SomeValue is the type of the value that will be returned. Let's assume a String is returned. The submit method should look like this: @Formable () abstract class _MyForm extends FormerForm { Future < String > submit ( BuildContext context ) async { // submission logic return '' ; } } Then, you should pass the type of the return value to FormerProvider.submit : final provider = Former . of < MyForm > ( context ); final result = provider . submit < String > (); Unfortunately, due to the limitation of Dart's type system, it is currently impossible to infer the return type of your implementation of the submit method.","title":"Returning results"},{"location":"form-submission/#delegating-submission-to-bloc","text":"It is also possible to delegate form submission to a bloc: @Formable () abstract class _MyForm extends FormerForm { Future < void > submit ( BuildContext context ) async { BlocProvider . of < MyBloc > ( context ). add ( FormSubmitted ( this )); } } Your bloc can get the form in two ways: From the event object added (as shown above), Obtain the form with Former.of(context).form . Pick an approach depending on your use case.","title":"Delegating submission to Bloc"},{"location":"installation/","text":"Installation Latest version: 0.2.0 NOTE: THIS PACKAGE IS IN BETA - API CAN CHANGE DRASTICALLY IN THE FUTURE. Add former to the dependencies section of your pubspec.yaml : dependencies : # ...your other dependencies former : # optionally lock-in a version and add former_gen to the dev_dependencies section: dev_dependencies : # ...your other dependencies former_gen : # optionally lock-in a version Finally, run flutter pub get .","title":"Installation"},{"location":"installation/#installation","text":"Latest version: 0.2.0 NOTE: THIS PACKAGE IS IN BETA - API CAN CHANGE DRASTICALLY IN THE FUTURE. Add former to the dependencies section of your pubspec.yaml : dependencies : # ...your other dependencies former : # optionally lock-in a version and add former_gen to the dev_dependencies section: dev_dependencies : # ...your other dependencies former_gen : # optionally lock-in a version Finally, run flutter pub get .","title":"Installation"},{"location":"usage/","text":"Usage This guide will go through how to use former . Creating the form former works by inspecting your form class and generating the corresponding code that makes it work with the former API. First, lets create our form class in my_form.dart : import 'package:former/former.dart' ; import 'package:former/validators.dart' ; import 'package:former_gen/former_gen.dart' ; @Formable () abstract class _MyForm extends FormerForm { } A couple of things to note: The form class is abstract and private. This is because some logic has to be mixed in before it is usable by former . The form class extends FormerForm . It interfaces our form class with former so that it can be used by former internals. The former.validators library is imported because the generated code will generate a schema class for _MyForm that specifies the respective validators that each field needs to use. The FormerForm requires subclasses to implement the bracket operators. This is not needed in our abstract class because that burden will be handled by former 's code generation. We only need to implement the submit method. For example, it can include submitting your form to some API for further processing. For simplicity's sake, our implementation of submit only returns an empty future value. Notice that the submit method accepts a BuildContext . This is the same BuildContext used by the Former widget that we will use later to provide this form. It can come in handy when you want to access other Provider s in the context. Just make sure that the Provider s you want to access are parents of the Former widget that is providing the form. @Formable () abstract class _MyForm extends FormerForm { @override Future < void > submit ( BuildContext context ) { // TODO: implement submit() return Future . value (); } } Let's also add some fields to our form: @Formable () abstract class _MyForm extends FormerForm { String username = '' ; String email = '' ; @override Future < void > submit ( BuildContext context ) { // TODO: implement submit() return Future . value (); } } Our form class is not usable until we mix in the generated mixin which makes the form \"indexable\" with the bracket operator, and also contain type information of the fields in the form. Add the following before the class declaration: class MyForm = _MyForm with _$MyForm ; ...and add this: part 'my_form.g.dart' ; to import the generated code. The Dart analyzer will complain about unrecognized symbols and imports. To fix it, start the code generation via build_runner : flutter pub run build_runner build Specifying the requirements Imagine that our form has the following requirements: the username should be at least 10 characters long, but not longer than 50 characters. the email field, well, should contain a valid email. Without former , this has to be done in an imperative way by, for example, checking the length of the string. former 's super declarative API for specifying requirements makes everything easy and readable. All you have to do is to create the schema class that is generated for you. In my_form.dart , final schema = MyFormSchema ( username: StringMust () .. hasMinLength ( 10 ) .. hasMaxLength ( 50 ), email: StringMust () .. beAnEmail (), ); As you can see, the API is very self-explanatory. Note the use of the cascade operator .. - in Dart, instead of returning this for method chaining, the cascade operator .. is preferred. Building form controls former exports various widgets that interacts with the given form. To start, let's first create our form widget: import 'package:flutter/material.dart' ; import 'package:former/former.dart' ; import 'my_form.dart' ; class Form extends StatelessWidget { @override Widget build () { return Column ( children: [ FormerTextField < MyForm > ( field: MyFormField . username ), FormerTextField < MyForm > ( field: MyFormField . email ), ElevatedButton ( onPressed: () { Former . of < MyForm > ( context , listen: false ). submit (); }, child: Text ( 'Submit form' ) ) ], ); } } Our form contains two text fields that control the username and the email field respectively. The MyFormField class is automatically generated for you, so you don't have to create one yourself. When the button is clicked, MyForm 's submit method is called to submit the form. Beside submitting the form, Former.of(context) gives you access to: the current form with .form . For example, you can access the current value of the username field with Former.of<MyForm>(context).form.username enabling/disabling the form with .isFormEnabled getter/setter. When a form is disabled, all the former controls controlling the form is automatically disabled as well. the error of a given field with .errorOf(field) which returns the error message as a result of a failed validation. It returns an empty string when the field is valid, or when no validation is performed yet. This is an extremely simplified version of a form to showcase the widgets. Realistically, each Former control should have a label describing what they do. In the future, there may be a widget that attaches a label to a Former control. For now, it has to be done manually. Wrapping it all up Finally, all we have to do is to wrap our form widget with the Former widget: import 'package:flutter/material.dart' ; import 'package:former/former.dart' ; import 'my_form.dart' ; class MyApp extends StatelessWidget { @override Widget build () { return MaterialApp ( home: Scaffold ( body: Former ( form: () => MyForm (), schema: () => schema , // exported from my_form.dart child: _MyForm (), ), ), ); } } Source code The full source code is available in the example folder.","title":"Usage"},{"location":"usage/#usage","text":"This guide will go through how to use former .","title":"Usage"},{"location":"usage/#creating-the-form","text":"former works by inspecting your form class and generating the corresponding code that makes it work with the former API. First, lets create our form class in my_form.dart : import 'package:former/former.dart' ; import 'package:former/validators.dart' ; import 'package:former_gen/former_gen.dart' ; @Formable () abstract class _MyForm extends FormerForm { } A couple of things to note: The form class is abstract and private. This is because some logic has to be mixed in before it is usable by former . The form class extends FormerForm . It interfaces our form class with former so that it can be used by former internals. The former.validators library is imported because the generated code will generate a schema class for _MyForm that specifies the respective validators that each field needs to use. The FormerForm requires subclasses to implement the bracket operators. This is not needed in our abstract class because that burden will be handled by former 's code generation. We only need to implement the submit method. For example, it can include submitting your form to some API for further processing. For simplicity's sake, our implementation of submit only returns an empty future value. Notice that the submit method accepts a BuildContext . This is the same BuildContext used by the Former widget that we will use later to provide this form. It can come in handy when you want to access other Provider s in the context. Just make sure that the Provider s you want to access are parents of the Former widget that is providing the form. @Formable () abstract class _MyForm extends FormerForm { @override Future < void > submit ( BuildContext context ) { // TODO: implement submit() return Future . value (); } } Let's also add some fields to our form: @Formable () abstract class _MyForm extends FormerForm { String username = '' ; String email = '' ; @override Future < void > submit ( BuildContext context ) { // TODO: implement submit() return Future . value (); } } Our form class is not usable until we mix in the generated mixin which makes the form \"indexable\" with the bracket operator, and also contain type information of the fields in the form. Add the following before the class declaration: class MyForm = _MyForm with _$MyForm ; ...and add this: part 'my_form.g.dart' ; to import the generated code. The Dart analyzer will complain about unrecognized symbols and imports. To fix it, start the code generation via build_runner : flutter pub run build_runner build","title":"Creating the form"},{"location":"usage/#specifying-the-requirements","text":"Imagine that our form has the following requirements: the username should be at least 10 characters long, but not longer than 50 characters. the email field, well, should contain a valid email. Without former , this has to be done in an imperative way by, for example, checking the length of the string. former 's super declarative API for specifying requirements makes everything easy and readable. All you have to do is to create the schema class that is generated for you. In my_form.dart , final schema = MyFormSchema ( username: StringMust () .. hasMinLength ( 10 ) .. hasMaxLength ( 50 ), email: StringMust () .. beAnEmail (), ); As you can see, the API is very self-explanatory. Note the use of the cascade operator .. - in Dart, instead of returning this for method chaining, the cascade operator .. is preferred.","title":"Specifying the requirements"},{"location":"usage/#building-form-controls","text":"former exports various widgets that interacts with the given form. To start, let's first create our form widget: import 'package:flutter/material.dart' ; import 'package:former/former.dart' ; import 'my_form.dart' ; class Form extends StatelessWidget { @override Widget build () { return Column ( children: [ FormerTextField < MyForm > ( field: MyFormField . username ), FormerTextField < MyForm > ( field: MyFormField . email ), ElevatedButton ( onPressed: () { Former . of < MyForm > ( context , listen: false ). submit (); }, child: Text ( 'Submit form' ) ) ], ); } } Our form contains two text fields that control the username and the email field respectively. The MyFormField class is automatically generated for you, so you don't have to create one yourself. When the button is clicked, MyForm 's submit method is called to submit the form. Beside submitting the form, Former.of(context) gives you access to: the current form with .form . For example, you can access the current value of the username field with Former.of<MyForm>(context).form.username enabling/disabling the form with .isFormEnabled getter/setter. When a form is disabled, all the former controls controlling the form is automatically disabled as well. the error of a given field with .errorOf(field) which returns the error message as a result of a failed validation. It returns an empty string when the field is valid, or when no validation is performed yet. This is an extremely simplified version of a form to showcase the widgets. Realistically, each Former control should have a label describing what they do. In the future, there may be a widget that attaches a label to a Former control. For now, it has to be done manually.","title":"Building form controls"},{"location":"usage/#wrapping-it-all-up","text":"Finally, all we have to do is to wrap our form widget with the Former widget: import 'package:flutter/material.dart' ; import 'package:former/former.dart' ; import 'my_form.dart' ; class MyApp extends StatelessWidget { @override Widget build () { return MaterialApp ( home: Scaffold ( body: Former ( form: () => MyForm (), schema: () => schema , // exported from my_form.dart child: _MyForm (), ), ), ); } }","title":"Wrapping it all up"},{"location":"usage/#source-code","text":"The full source code is available in the example folder.","title":"Source code"},{"location":"validation/","text":"Validation former has a fluent, declarative API for performing form validation. Built-in validators Below is a list of validators that former comes with. BoolValidator validates a bool field. NumberValidator validates a number field. StringValidator validates a string field. Custom error messages By default, every constraint method of the built-in validators has a default error message whenever validation fails. You can pass in a custom error message as the last argument to the constraint methods to override the default messages. StringMust ().. beAnEmail ( 'Please enter a valid email!' ); FormerError will display the custom error messages if given, instead of the default error messages. Custom validators You can create custom validators that validate fields of custom types. Create a class that implements Validator , and pass in the type that you want to validate through the type parameter of Validator . Then, implement all the required methods. Example Below shows a simple Validator that validates values of type User . class UserValidator extends Validator < User > { /// The error message as a result of an invalid value. String _error = '' ; @override String get error => _error ; /// Returns false if [value] is invalid, true if valid. @override bool validate ( User ? value ) { // validation logic } } Fluent API convention Below are conventions for a fluent Validator API similar to the built-in validators. Validator name SHOULD follow <type-name>Must , so that it forms a complete sentence with its methods. Constraint methods SHOULD form a complete sentence with the validator name. For example UserMust()..hasAUsername() Constraint methods SHOULD return void , and SHOULD NOT return this .","title":"Validation"},{"location":"validation/#validation","text":"former has a fluent, declarative API for performing form validation.","title":"Validation"},{"location":"validation/#built-in-validators","text":"Below is a list of validators that former comes with. BoolValidator validates a bool field. NumberValidator validates a number field. StringValidator validates a string field.","title":"Built-in validators"},{"location":"validation/#custom-error-messages","text":"By default, every constraint method of the built-in validators has a default error message whenever validation fails. You can pass in a custom error message as the last argument to the constraint methods to override the default messages. StringMust ().. beAnEmail ( 'Please enter a valid email!' ); FormerError will display the custom error messages if given, instead of the default error messages.","title":"Custom error messages"},{"location":"validation/#custom-validators","text":"You can create custom validators that validate fields of custom types. Create a class that implements Validator , and pass in the type that you want to validate through the type parameter of Validator . Then, implement all the required methods.","title":"Custom validators"},{"location":"validation/#example","text":"Below shows a simple Validator that validates values of type User . class UserValidator extends Validator < User > { /// The error message as a result of an invalid value. String _error = '' ; @override String get error => _error ; /// Returns false if [value] is invalid, true if valid. @override bool validate ( User ? value ) { // validation logic } }","title":"Example"},{"location":"validation/#fluent-api-convention","text":"Below are conventions for a fluent Validator API similar to the built-in validators. Validator name SHOULD follow <type-name>Must , so that it forms a complete sentence with its methods. Constraint methods SHOULD form a complete sentence with the validator name. For example UserMust()..hasAUsername() Constraint methods SHOULD return void , and SHOULD NOT return this .","title":"Fluent API convention"},{"location":"form-controls/custom-control/","text":"Custom control In some cases the built-in controls just won't cut it. former allows you to build custom form controls that will suit your needs the best. Custom controls are just normal widgets that interact with former 's API. Obtaining FormerProvider FormerProvider is a ChangeNotifier that holds the current form. It provides various methods to interact with the form. You can obtain the instance of FormerProvider that is controlling your form with: final provider = Former . of < MyForm > ( context ); The generic type must match the type of your form. Otherwise, former will not be able to locate the provider. Value handling Built-in controls handle value tracking and updating for you. However, in a custom control, you need to do that manually. FormerProvider has an update method that lets you update a field with the given value. Let's assume you have a login form called LoginForm , and you want to update the username field. To do so, call the update method as such: provider . update ( LoginFormField . username , 'NewUsername' ); The first parameter takes in the field that you want to update, in this case username (The LoginFormField is automatically generated for you that includes all the fields of your form). The second parameter takes in the new value that you want the field to hold, in this case 'NewUsername' .","title":"Custom control"},{"location":"form-controls/custom-control/#custom-control","text":"In some cases the built-in controls just won't cut it. former allows you to build custom form controls that will suit your needs the best. Custom controls are just normal widgets that interact with former 's API.","title":"Custom control"},{"location":"form-controls/custom-control/#obtaining-formerprovider","text":"FormerProvider is a ChangeNotifier that holds the current form. It provides various methods to interact with the form. You can obtain the instance of FormerProvider that is controlling your form with: final provider = Former . of < MyForm > ( context ); The generic type must match the type of your form. Otherwise, former will not be able to locate the provider.","title":"Obtaining FormerProvider"},{"location":"form-controls/custom-control/#value-handling","text":"Built-in controls handle value tracking and updating for you. However, in a custom control, you need to do that manually. FormerProvider has an update method that lets you update a field with the given value. Let's assume you have a login form called LoginForm , and you want to update the username field. To do so, call the update method as such: provider . update ( LoginFormField . username , 'NewUsername' ); The first parameter takes in the field that you want to update, in this case username (The LoginFormField is automatically generated for you that includes all the fields of your form). The second parameter takes in the new value that you want the field to hold, in this case 'NewUsername' .","title":"Value handling"},{"location":"form-controls/introduction/","text":"Introduction former comes with a bunch of form controls that can be used to modify a form. All of them are simple wrappers around common Flutter widgets that are used to build forms: FormerTextField wraps TextField FormerCheckbox wraps Checkbox etc. All former controls accepts arguments for the constructor of the widget that they wrap. For example, The constructor of FormerTextField has the same set of parameters as TextField . Enabling/disabling controls By default, all former controls follow whether the form in context is disabled. If the form is disabled, then all the former controls that control the form are disabled as well. You can override this behavior by passing in a value for the enabled parameter. List of controls Below are a list of controls that are currently available. They are links to API references of the former controls. FormerCheckbox ( docs ) FormerSlider ( docs ) FormerSwitch ( docs ) FormerTextField ( docs )","title":"Introduction"},{"location":"form-controls/introduction/#introduction","text":"former comes with a bunch of form controls that can be used to modify a form. All of them are simple wrappers around common Flutter widgets that are used to build forms: FormerTextField wraps TextField FormerCheckbox wraps Checkbox etc. All former controls accepts arguments for the constructor of the widget that they wrap. For example, The constructor of FormerTextField has the same set of parameters as TextField .","title":"Introduction"},{"location":"form-controls/introduction/#enablingdisabling-controls","text":"By default, all former controls follow whether the form in context is disabled. If the form is disabled, then all the former controls that control the form are disabled as well. You can override this behavior by passing in a value for the enabled parameter.","title":"Enabling/disabling controls"},{"location":"form-controls/introduction/#list-of-controls","text":"Below are a list of controls that are currently available. They are links to API references of the former controls. FormerCheckbox ( docs ) FormerSlider ( docs ) FormerSwitch ( docs ) FormerTextField ( docs )","title":"List of controls"}]}